#!/usr/bin/env python
# coding: utf-8

# <font color=blue> Привет еще раз. Спасибо, что доделал работу. Мои комментарии на этот раз выделены синим цветом.
#     
# ---

# ---
# ## Комментарий от наставника
# 
# Привет! Спасибо, что прислал задание:) Поздравляю с первым сданным проектом. В целом, работа производит неплохое впечатление, однако обрати внимание на некоторые мои комментарии. Они обозначены пометкой **Комментарий от наставника**. Пострайся учесть эти комментарии.
# 
# ---

# ## Исследование надёжности заёмщиков
# 
# Заказчик — кредитный отдел банка. Нужно разобраться, влияет ли семейное положение и количество детей клиента на факт погашения кредита в срок. Входные данные от банка — статистика о платёжеспособности клиентов.
# 
# Результаты исследования будут учтены при построении модели **кредитного скоринга** — специальной системы, которая оценивает способность потенциального заёмщика вернуть кредит банку.
# 
# Описание данных
# - children — количество детей в семье
# - days_employed — общий трудовой стаж в днях
# - dob_years — возраст клиента в годах
# - education — уровень образования клиента
# - education_id — идентификатор уровня образования
# - family_status — семейное положение
# - family_status_id — идентификатор семейного положения
# - gender — пол клиента
# - income_type — тип занятости
# - debt — имел ли задолженность по возврату кредитов
# - total_income — ежемесячный доход
# - purpose — цель получения кредита

# ---
# ## Комментарий от наставника
# 
# 
# Правильно, что есть краткое вступление в работу, описание того, что надо делать. В работе необходимо приводить краткий план того, что надо сделать(если этот план имеется), а также информацию о входных данных: какие столбцы есть в таблице, их названия и какую информацию они несут (см. пример). Также название работы лучше отображать в отдельной ячейке и делать крупный шрифт (заголовок). Так работа выглядит презентабельно.
# 
# <font color=red> Пример: </font>
# ---
# Описание данных: 
# - children — количество детей в семье
# - days_employed — общий трудовой стаж в днях
# - dob_years — возраст клиента в годах
# - education — уровень образования клиента
# - education_id — идентификатор уровня образования
# - ...
#     
#     
# ---

# ### Шаг 1. Откройте файл с данными и изучите общую информацию. 

# In[110]:


import pandas as pd
clients = pd.read_csv('/datasets/data.csv')


# In[111]:


clients


# In[112]:


clients.info()


# # Выводы

# у датафрейма есть пропуски в столбце days_employed — общий трудовой стаж в днях и total_income — ежемесячный доход (это может быть связано что человек не предоставил оригиналы или заверенные копии трудовой книжки). 
# по быстрому просмотру можно сделать выводы days_employed имеет ошибки, т.к. стаж не может быть отрицательным, и быть выше чем продолжительность жизни

# ---
# ## Комментарий от наставника
# 
# У меня имеется пара комментариев по данному шагу:
# - считывание данных и импорт необходимых библиотек лучше проводить в разных ячейках;
# - следует давать переменным осознанные имена. Таблица про клиентов - название надо бы выбрать соответствующее;
# - Подумай также о возможных причинах появления пропусков, а также о том, являются ли они случайными или нет.
# 
# Первый взгляд на таблицу выполнен.
# 
# ---

# ### Шаг 2. Предобработка данных

# ### Обработка пропусков

# In[113]:


def fix_days(age):
    return clients[clients['dob_years'] == age]['days_employed'].median()
clients.loc[clients['days_employed'].isnull(), 'days_employed'] = clients.loc[clients['days_employed'].isnull(), 'dob_years'].apply(fix_days)


# In[114]:


def fix_income(row):
    education_id = row['education_id']
    income_type = row['income_type']
    mask = (clients['total_income'].notnull()) & (clients['education_id'] == education_id) & (clients['income_type'] == income_type)
    return clients[mask]['total_income'].median()
clients.loc[clients['total_income'].isnull(), 'total_income'] = clients[clients['total_income'].isnull()].apply(fix_income, axis = 1)


# In[115]:


clients.info()


# ### Вывод

# Пропуски в стаже заменим по медиане взятой от возраста
# 
# Пропуски в доходе заменим медианой взятой от сочетаниям образования и типа занятости 

# <font color=blue> Пропуски теперь обработаны верно. Интересный способ реализации заполнения пропусков, молодец. 
#     
# ---

# ---
# ## Комментарий от наставника
# 
# Лучше использовать заполнение пропусков в соответствии с типом дохода. Тогда пенсионеры будут получать также, как и другие пенсионеры и т.д. Все-таки в данных есть достаточное число групп, заполнять пропуски в стаже, скажем, у студентов и пенсионеров одним и тем же значением не очень то правильно. То же самое касается и столбца с доходами: пропуски у предпринимателя и пенсионера заполняются одним числом, что вызывает вопросы. Подумай, как лучше обработать пропуски.
# 
# ---

# ### Замена типа данных

# In[116]:


clients.loc[clients['days_employed'] < 0,['days_employed']] = clients.loc[clients['days_employed'] < 0,['days_employed']] * (-1)


# Избавились от минусовых значений в стаже

# In[117]:


clients['dob_years'].max()


# In[118]:


max_rab_hour= (75-18)*365
clients.loc[clients['days_employed'] >= max_rab_hour,['days_employed']]  = clients.loc[clients['days_employed'] >= max_rab_hour,['days_employed']] /24

clients.sort_values(by = 'days_employed', ascending=False)


# Предположим что весь аномальный возраст эказан в часах и таким образом найдем все значения по условию что максимальный возраст заемщика из дата фрейма отнимаем 18 лет и делим все это значение на 24 тем самым получаем кол-во отработанных дней

# In[119]:


clients['days_employed'].max()


# In[120]:


clients['education']=clients['education'].str.lower()
clients['family_status'] =  clients['family_status'].str.lower()


# In[121]:


sover = 365*14
a = clients.loc[clients['days_employed'] +sover  > clients['dob_years']*365]
print(a)


# Получаем 996 записей с артефактами, проверка на логику была такая что берем кол-во отработанных дней складываем с  совершеннолетие. Получается кол-во дней которое человек мог отработать если его стаж считать с первого дня   14 летия.
# 
# 
# 

# In[122]:


clients = clients[clients['days_employed'] + sover <= clients['dob_years']*365]


# In[123]:


clients['children'].value_counts()


# In[124]:


clients.loc[clients['children'] == 20,['children']] = 2
clients.loc[clients['children'] == -1,['children']] = 1


# In[125]:


clients['children'].value_counts()


# In[126]:


clients['days_employed'] = clients['days_employed'].astype('int64')
clients['total_income'] = clients['total_income'].astype('int64')


# In[127]:


clients.info()


# ### Вывод

# Мы избавились от пустых значений, выявили артефакты возраст - стаж (то что стаж + 18 летие) не может быть больше  возраста
# 
# а так же стаж и доход привели к целочисленному значению

# <font color=blue> Тип данных изменен у необходимых столбцов. Все правильно. 
#     
# ---

# ---
# ## Комментарий от наставника
# 
# Исходя из общей информации о таблице мы видим, что два столбца имеют вещественный тип данных, который и надо заменить на целочисленный. Это замена не произведена. Проведи замены типа для указанных столбцов. Здорово, что исправлены ошибки в данных. 
# 
# ---

# ### Обработка дубликатов

# In[128]:


clients.duplicated().sum()


# In[129]:


clients = clients.drop_duplicates().reset_index(drop=True)


# ### Вывод

# Было найдено 71 запись дублирующая от которых мы избавились и можем приступить к лемматизаци
# 

# ---
# ## Комментарий от наставника
# 
# Дубликаты вызывают смещение финальных результатов, поэтому их и надо удалять. Конечно, в данных нет уникального идентификатора, однако надо уметь удалять дубликаты. Метод drop_duplicates() использован верно.
# 
# ---

# ### Лемматизация

# In[130]:


from pymystem3 import Mystem
m = Mystem()
purpose_uniq=clients['purpose'].unique()
#print(purpose_uniq)
for element in purpose_uniq:
    try:
        print(m.lemmatize(element))
    except:
        print ('Проверь цель', element)
def purpose_new(purpose):
    words= [
        ['жиль', 'недвижимость'],
        ['недвижимост','недвижимость'],
        ['свадьб','свадьба'],
        ['автомобил','автомобиль'],
        ['образован','образование']
    ]
    for word in words:
        if word[0] in purpose:
            return word[1]

clients['purpose_update']=clients['purpose'].apply(purpose_new)
clients.head(10)
    


# ### Вывод

#  С помощью лемматизации привели цели кредита к 5и общим целям которые встречаются по всему набору данных: Жилье, недвижимость, авто, образование и всё что связано со свадьбой  

# ---
# ## Комментарий от наставника
# 
# Все верно, метод lemmatize() использован правильно. Стоит подробнее объяснить выбор лемм.
# 
# ---

# ### Категоризация данных

# In[131]:


def ch_group(b):

        if b == 1:
                return 'один'
        if b == 2:
                return 'двое'
        if b >= 3:
                return 'многодетные'
        return 'бездетные'
clients['ch_group'] = clients['children'].apply(ch_group)
print(clients.head(10))


# In[132]:


def purpose_group(tip):
    if tip == 'недвижимость':
        return 'ипотека'
    if tip == 'автомобиль':
        return 'автокредит'
    if tip == 'образование':
        return 'образование'
    return 'свадьба'
clients ['purpose_group']=clients['purpose_update'].apply(purpose_group)
print(clients.head(10))
    


# In[133]:


clients['income_group']=pd.qcut(clients['total_income'], 5)


# ### Вывод

# При помощи категоризации данных цели кредита привели 4 основным - ипотека, свадьба, образование и автокредит
# а так же при помощи квантилии доход разделили на 5 групп

# In[135]:


clients.query("purpose_group == 'свадьба'").purpose.unique()


# ---
# ## Комментарий от наставника
# 
# В лемму "потребительский" кредит входят только расходы на проведение свадьбы. Стоит переименовать ее. 
# 
# Категоризовать также надо и столбец с доходами. Это есть ниже, а должно быть в данном разделе. 
# 
# ---

# ### Шаг 3. Ответьте на вопросы

# - Есть ли зависимость между наличием детей и возвратом кредита в срок?

# In[136]:


clients['direction']=clients['debt']
print(clients.info())


# In[141]:


deti_pivot = clients.pivot_table(index='ch_group', columns='debt', values='direction', aggfunc='count', fill_value=0)
deti_pivot['vozvrat'] = deti_pivot[1]/(deti_pivot[0]+deti_pivot[1]) 
deti_pivot = deti_pivot.sort_values(by='vozvrat', ascending = False)
#print ('{:>11} | {:>10} | {:>10} | {:>10}'.format('Наличие детей', 'Возраты', 'Невозвраты', '% невозратов'))
#for row in deti_pivot.iterrows():
    #print('{:>11} | {:>10.0f} | {:>10.0f} | {:>12.1%}'.format(row[0], row[1][0], row[1][1], row[1]['vozvrat']))
deti_pivot


# ### Вывод

# Заемщики не имеющие детей более отвественно относятся к возврату займа.

# In[138]:


deti_pivot


# ---
# ## Комментарий от наставника
# 
# Лучше просто вывести таблицу. 
# 
# ---

# - Есть ли зависимость между семейным положением и возвратом кредита в срок?

# In[142]:


sm_pivot = clients.pivot_table(index='family_status', columns='debt', values='direction', aggfunc='count', fill_value=0)
sm_pivot['vozvrat'] = sm_pivot[1]/(sm_pivot[0]+sm_pivot[1]) 
sm_pivot = sm_pivot.sort_values(by='vozvrat', ascending = False)
sm_pivot
#print ('{:>20} | {:>10} | {:>10} | {:>10}'.format('Семейное положение', 'Возвраты', 'Невозвраты', '% невозратов'))
#for row in sm_pivot.iterrows():
    #print('{:>20} | {:>10.0f} | {:>10.0f} | {:>12.1%}'.format(row[0], row[1][0], row[1][1], row[1]['vozvrat']))


# ### Вывод

# Наблюдается прямая корреляция семейного положения и возврата кредита: люди не имеющие официально зарегистрированного брака, в большей степени склонны не возвращать займ 

# ---
# ## Комментарий от наставника
# 
# Вывод не противоречит полученному результату. 
# 
# ---

# - Есть ли зависимость между уровнем дохода и возвратом кредита в срок?

# In[143]:


dh_pivot = clients.pivot_table(index='income_group', columns='debt', values='direction', aggfunc='count', fill_value=0)
dh_pivot['vozvrat'] = dh_pivot[1]/(dh_pivot[0]+dh_pivot[1]) 
dh_pivot = dh_pivot.sort_values(by='vozvrat', ascending = False)
dh_pivot
#print ('{:>20} | {:>10} | {:>10} | {:>10}'.format('Уровень дохода', 'Возвраты', 'Невозвраты', '% невозратов'))
#for row in dh_pivot.iterrows():
    #print('{} | {:>10.0f} | {:>10.0f} | {:>12.1%}'.format(row[0], row[1][0], row[1][1], row[1]['vozvrat']))


# ### Вывод

#  Люди с наибольшим доходом и наименьшим более склонны к возврату кредита в срок, а вот люди со средним и миниальным доходом наоборт

# ---
# ## Комментарий от наставника
# 
# Верный способ категоризации с помощью квантилей данного столбца. Так группы получаются равного размера. Выводы будут надежными. 
# 
# ---

# - Как разные цели кредита влияют на его возврат в срок?

# In[144]:


purpose_pivot = clients.pivot_table(index='purpose_group', columns='debt', values='direction', aggfunc='count', fill_value=0)
purpose_pivot['vozvrat'] = purpose_pivot[1]/(purpose_pivot[0]+purpose_pivot[1]) 
purpose_pivot = purpose_pivot.sort_values(by='vozvrat', ascending = False)
purpose_pivot
#print ('{:>20} | {:>10} | {:>10} | {:>10}'.format('Цель кредита', 'Возвраты', 'Невозвраты', '% невозратов'))
#for row in purpose_pivot.iterrows():
    #print('{:>20} | {:>10.0f} | {:>10.0f} | {:>12.1%}'.format(row[0], row[1][0], row[1][1], row[1]['vozvrat']))


# ### Вывод

# Люди берующиие ипотеку возвращают займы чаще, чем люди берующие займ на авто и образование. 

# ---
# ## Комментарий от наставника
# 
# Здорово, что при анализе использован метод сводных таблиц. Он пригодится в дальнейших проектах.
# 
# Выводы верные по всем пунктам. 
# 
# ---

# ### Шаг 4. Общий вывод

# В ходе работы мы избавились от пропусков в стаже работы заменив его на медиану стажа людей аналогичного возраста
# а так же пропуски в доходе были изменены на медиану взятой от сочетаниям образования и типа занятости.
# Были удалены записи которые были казались абсурдными к примеру общий стаж + совершеннолетие больше чем возраст заемщика, очевидно что записи с ошибками.
# 
# была сделана категоризация данных, а так же сделаны квантилии по уровню дохода.
# 
# В ходе работы была выявлена тенденция что наиболее благоприятная группа для выдачи кредита это: люди когда-либо состоявшие в официальном браке, не имеющие детей, и целью кредита которых является ипотека.
# 
# А так же группа людей которые чаще всего не возвращают кредит это люди берующие автокредиты, не женатые и имеющие двоих детей)
# 
# Для получения итоговых данных использовал метод сводных таблиц 

# <font color=blue> Выводы стали лучше. Приведены ответы на главные вопросы проекта. Также здорово, что описано то, что было сделано в работе. 
#     
# ---

# ---
# ## Комментарий от наставника
# 
# Финальный вывод и есть главный результат твоей работы. Стоит писать его подробно по результатам проведенной работы. В нем можно приводить полученные в ходе работы значения. Также можно расписать все, что было сделано в работе.
# 
# ---

# <font color=blue> Помарки исправлены, и теперь работа выполнена хорошо. Успехов в дальнейших проектах :)
#     
# ---

# ## Комментарий от наставника
# 
# - В начале работы следует описывать данные, с которыми работаешь;
# - Используй альтернативный способ обработки пропусков;
# - Тип данных надо изменить у столбцов со стажем и с доходами;
# - Финальный вывод стоит писать подробно.
# 
# Ты проделал большую работу, молодец! Исправь отмеченные тут замечания, и получится очень достойная работа :)
# 
# -----

# # Чек-лист готовности проекта
# 
# Поставьте 'x' в выполненных пунктах. Далее нажмите Shift+Enter.
